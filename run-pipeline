#!/usr/bin/env python3
from argparse import ArgumentParser
import logging
from runpy import run_path
import sys

from torchbear.event import (
    Listener,
    Queue,
    )
from torchbear.pipeline import (
    DependentTarget as Target,
    Pipeline,
    )
from torchbear.step import ShellStep


def get_logging_level(verbose_count):
    verbose_count += 2
    levels = (logging.CRITICAL, logging.ERROR, logging.WARNING, logging.INFO,
              logging.DEBUG)
    verbose_count = min(verbose_count, len(levels) - 1)
    return levels[verbose_count]


def parse_args():
    parser = ArgumentParser()
    parser.add_argument('target', nargs='?', help='The target to run.')
    parser.add_argument('-v', '--verbose', action='count',
                        default=0, dest='verbosity')
    return parser.parse_args()


def find_target(target_id, pipeline):
    if target_id is None:
        return
    for target in pipeline.targets:
        if target.target_id == target_id:
            return target
    else:
        raise LookupError('Could not find target {}'.format(target_id))


def main():
    args = parse_args()
    logging.basicConfig(level=logging.WARNING)
    logging_level = get_logging_level(args.verbosity)
    logging.getLogger().setLevel(logging_level)
    with Pipeline.build() as pipeline:
        run_path('./torchbear.tb', init_globals={
            'Target': Target,
            'ShellStep': ShellStep,
            })
    try:
        target = find_target(args.target, pipeline)
    except LookupError as e:
        print(e, file=sys.stderr)
        sys.exit(1)
    Listener(Queue()).run_pipeline(pipeline, target)


if __name__ == '__main__':
    main()
